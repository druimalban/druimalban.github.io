[{"path":"/articles/fixed-point-programming.html","id":"preface","dir":"Articles","previous_headings":"","what":"Preface","title":"Programming with fixed-points","text":"exploring catamorphisms, originally implemented using functions Fix() unFix() behaved like Haskell counterparts. contrast, recursion-schemes package implements project() embed() functions together, “base” functors e.g. lists, idea “base” functor represents one layer recursion. don’t think names particularly intuitive, project() equivalent unFix() peels back layer recursion, embed() equivalent Fix() applies layer recursion. originally followed Mark Seemann’s blog, turn uses Fix Bartosz Milewski’s article F-Algebras. Furthermore, Haskell Wikibook section explores Haskell’s fix recursion.","code":""},{"path":"/articles/fixed-point-programming.html","id":"fixed-points","dir":"Articles","previous_headings":"","what":"Fixed points","title":"Programming with fixed-points","text":"Cheating bit—Fix() just wraps another layer recursion, recursive type signature like Haskell’s fix—defined Fix() unFix() functions follows.","code":"Fix <- function (expr) {     res         = list (type = \"Fix\", content = expr)     class (res) = append (class (res), \"fixed.point\")     return (res) }  unFix <- function (fx) {     if (\"fixed.point\" %in% class (fx))         return (fx$content) }  is.fixed.point <- function (fx) {     return (\"fixed.point\" %in% class (fx)) }"},{"path":"/articles/fixed-point-programming.html","id":"redefining-cata-and-ana","dir":"Articles","previous_headings":"","what":"Redefining cata() and ana()","title":"Programming with fixed-points","text":"Let’s define cata() ana() terms unFix() Fix() (just slot ).","code":"cata_ <- function (alg, expr)     unFix (expr) |> fmap (\\(x) cata_ (alg, x)) |> alg ()  ana_ <-  function (coalg, expr)     coalg (expr) |> fmap (\\(x) ana_ (coalg, x)) |> Fix ()"},{"path":"/articles/fixed-point-programming.html","id":"defining-peano-natural-numbers","dir":"Articles","previous_headings":"","what":"Defining Peano natural numbers","title":"Programming with fixed-points","text":"Peano zero defined, function Succ() wrap . straightforward.","code":"Zero <- function () {     res         = list (type = \"Zero\")     class (res) = \"Natural\"     return (res) } Succ <- function (x) {     res         = list (type = \"Succ\", content = x)     class (res) = \"Natural\"     return (res) }  is.Zero <- function (n) {     if (\"Natural\" %in% class (n))         return (n$type == \"Zero\")     else return (FALSE) }  is.Succ <- function (n) {     if (\"Natural\" %in% class (n))         return (n$type == \"Succ\")     else return (FALSE) }  fmap.Natural <- function (st, f) {     if (is.Succ (st)) {         x  = f (st$content)         return (Succ (x))     }     else if (is.Zero (st))         return (st) }"},{"path":"/articles/fixed-point-programming.html","id":"test-data","dir":"Articles","previous_headings":"","what":"Test data","title":"Programming with fixed-points","text":"Now, define test data, numbers 0-3.","code":"zero  = Fix (Zero ()) one   = Fix (Succ (zero)) two   = Fix (Succ (one)) three = Fix (Succ (two))"},{"path":"/articles/fixed-point-programming.html","id":"simple-recursive-functions","dir":"Articles","previous_headings":"","what":"Simple recursive functions","title":"Programming with fixed-points","text":"Given catamorphism, can just go ahead define functions call cata() order pretty-print tally values. Example output:","code":"printNats <- function (st) {     pn = function (x) {         if (is.Zero (x))             return (\"Zero\")         else if (is.Succ (x)) {             exprStr = paste (\"Succeeds (\", x$content, ')', sep='')             return (exprStr)         }     }     res = cata_ (pn, st)     return (res) }  tallyNats <- function (st) {     tn = function (x) {         if (is.Zero (x))             return (0)         else if (is.Succ (x))             return (x$content + 1)     }     res = cata_ (tn, st)     return (res) } printNats (zero) #> [1] \"Zero\" tallyNats (zero) #> [1] 0  printNats (one) #> [1] \"Succeeds (Zero)\" tallyNats (one) #> [1] 1  printNats (two) #> [1] \"Succeeds (Succeeds (Zero))\" tallyNats (two) #> [1] 2  printNats (three) #> [1] \"Succeeds (Succeeds (Succeeds (Zero)))\" tallyNats (three) #> [1] 3"},{"path":"/articles/fixed-point-programming.html","id":"more-recursive-functions","dir":"Articles","previous_headings":"","what":"More recursive functions","title":"Programming with fixed-points","text":"Following Seemann’s blog post linked earlier, can define additional functions: natF(), applies function f many depths structure; incr(), increments given Peano representations one; add(), adds two Peano representations; mult(), multiplies two Peano representations; toNum(), “expands” given Peano expression integer representation; fromNum(), “compresses” given whole number Peano representation. Example output:","code":"natF = function (z, f, expr) {     alg = function (x) {         if (is.Zero (x))             return (z)         else if (is.Succ (x)) {             pre = x$content             return (f (pre))         }     }     return (cata_ (alg, expr)) }  incr <- function (expr)     return (natF (one, \\(x) Fix (Succ (x)), expr))  add <- function (ex, ey)     return (natF (ey, incr, ex))  mult <- function (ex, ey)     return (natF (zero, \\(x) add (ey, x), ex))  toNum <- function (expr) {     expand = function (st) {         if (is.Zero (st))             return (0)         else if (is.Succ (st)) {             return (st$content + 1)         }     }     res = cata_ (expand, expr)     return (res) }  fromNum <- function (n) {     compress = function (x) {         if (x == 0)             return (Zero ())         else if (x > 0)             return (Succ (x-1))     }     res = ana_ (compress, n)     return (res) } fromNum (4)  |> printNats () #> [1] \"Succeeds (Succeeds (Succeeds (Succeeds (Zero))))\" fromNum (32) |> tallyNats () #> [1] 32 incr (fromNum (4))               |> tallyNats () #> [1] 5 add  (fromNum (4), fromNum (2))  |> tallyNats () #> [1] 6 mult (fromNum (4), fromNum (12)) |> tallyNats () #> [1] 48"},{"path":"/articles/fixed-point-programming.html","id":"final-words","dir":"Articles","previous_headings":"","what":"Final words","title":"Programming with fixed-points","text":"main draw-back approach requires defining recursive fixed point variables, whereas approach taken recursion-schemes package “base” functors allows working directly structures question. However, able see unFix() Fix() relate project() embed() functions useful learning exercise.","code":""},{"path":[]},{"path":"/articles/list-morphisms.html","id":"catamorphism","dir":"Articles","previous_headings":"Folds","what":"Catamorphism","title":"Morphisms for a list","text":"catamorphism universal abstraction tearing functor structure. simple recursion feasible print list follows: can rewritten catamorphism:","code":"printListSimple <- function (lst) {     if (length (lst) == 0)         return (\"nil\")     else {         topNode  = lst[[1]]         allNodes = lst[-1]          return (paste (topNode, \": \", printListSimple (allNodes), sep=''))     } }  printListSimple (as.list (1:10)) #> [1] \"1: 2: 3: 4: 5: 6: 7: 8: 9: 10: nil\" printListCata <- function (lst) {     alg = function (l) {         if (is.NilF (l))             return (\"nil\")          else if (is.ConsF (l))             return (paste (l$attr, \": \", l$carrier, sep='', collapse=''))     }     return (cata (alg, lst)) }  printListCata (as.list (1:10)) #> [1] \"1: 2: 3: 4: 5: 6: 7: 8: 9: 10: nil\""},{"path":"/articles/list-morphisms.html","id":"paramorphism","dir":"Articles","previous_headings":"Folds","what":"Paramorphism","title":"Morphisms for a list","text":"paramorphism variant catamorphism, one provides access current sub-structure given point. algebra needs interpret tuples carrier type. following function appends size sub-structure end list element:","code":"printIndent <- function (lst) {     alg = function (l) {         if (is.NilF (l))             return (list())         else {             x  = l$attr             xs = l$carrier             xsa = first (xs)             xsc = second (xs)              indent = replicate (length (xsa), '>')             pasted = paste (indent, sep='', collapse='')                          return (append (xsc                           , paste (x, pasted, sep='')                           , after=0))         }     }     return (para (alg, lst)) }  printIndent (list (1,2,3,4)) #> [[1]] #> [1] \"1>>>\" #>  #> [[2]] #> [1] \"2>>\" #>  #> [[3]] #> [1] \"3>\" #>  #> [[4]] #> [1] \"4\""},{"path":"/articles/list-morphisms.html","id":"histomorphism","dir":"Articles","previous_headings":"Folds","what":"Histomorphism","title":"Morphisms for a list","text":"histomorphism goes still providing access previous values recursion. stored structure provided cofree, embedded throughout list base functor’s carrier. following function skips elements even indices. function https://jtobin.io/time-traveling-recursion.","code":"currElement <- function (l)     return (l$attr)  peelBack <- function (l)     return (l$carrier)  oddIndices <- function (lst) {     alg = function (l) {         if (is.NilF (l))             return (list())         else {             h0  = currElement (l)             cf0 = peelBack (l)             xs0 = peelBack (cf0)              if (is.NilF (xs0))                 return (list (h0))             else {                 h1  = currElement (xs0)                 cf1 = peelBack (xs0)                 t1  = currElement (cf1)                  return (c(h0, t1))             }               }     }     return (histo (alg, lst)) }  oddIndices (as.list (1:10)) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 3 #>  #> [[3]] #> [1] 5 #>  #> [[4]] #> [1] 7 #>  #> [[5]] #> [1] 9"},{"path":[]},{"path":"/articles/list-morphisms.html","id":"anamorphism","dir":"Articles","previous_headings":"Unfolds","what":"Anamorphism","title":"Morphisms for a list","text":"anamorphism categorical dual catamorphism. unfolds structure list, rather folding list structure something else, .e. builds structure rather tearing like catamorphism . following functions equivalent .list(unlist(recursive=T)). build simple list complex structure, case list lists. Compare lack recursive calls latter, former.","code":"collapseListsSimple <- function (lst) {     if (length (lst) == 0)         return (list ())     else {         x  = lst[[1]]         xs = lst[-1]                  if (is.list (x) && length (xs) == 0)             collapseListsSimple (x)         else if (!is.list (x) && length (xs) == 0)             list (x)         else if (is.list (x) && length (xs) > 0)             c (collapseListsSimple (x), collapseListsSimple (xs))         else if (!is.list (x) && length (xs) > 0)             append (collapseListsSimple (xs), x, after=0)     } }  collapseListsSimple (list(list(1,2,3),list(4,5,6),list(list(7,8),9,list(10,11)))) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  #> [[6]] #> [1] 6 #>  #> [[7]] #> [1] 7 #>  #> [[8]] #> [1] 8 #>  #> [[9]] #> [1] 9 #>  #> [[10]] #> [1] 10 #>  #> [[11]] #> [1] 11 collapseListsAna <- function (lst) {     coalg = function (x) {         if (length (x) == 0)             return (NilF())         else {             x_ = x[[1]]             xs = x[-1]              if (length (xs) == 0)                  ConsF (x_, list())             else if (length (xs) == 1)                  ConsF (x_, xs[[1]])             else ConsF (x_, xs)         }     }     return (ana (coalg, lst)) }  collapseListsAna (list(list(1,2,3),list(4,5,6),list(list(7,8),9,list(10,11)))) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5 #>  #> [[6]] #> [1] 6 #>  #> [[7]] #> [1] 7 #>  #> [[8]] #> [1] 8 #>  #> [[9]] #> [1] 9 #>  #> [[10]] #> [1] 10 #>  #> [[11]] #> [1] 11"},{"path":"/articles/list-morphisms.html","id":"apomorphism","dir":"Articles","previous_headings":"Unfolds","what":"Apomorphism","title":"Morphisms for a list","text":"apomorphism categorical dual paramorphism. allows recursion terminated point. following function implementation tails function. function designed returns list tails given list apomorphism traverses list structure. Note use Left() Right(). Left value provided, paramorphism just return whatever value , .e. ’ve stopped recursion. Right value provided, recursion continues. ’s useful , function doesn’t stop empty list. can stop arbitrary leading values, e.g. zero:","code":"tailsApo <- function (lst) {     coalg = function (a) {         projected = project (a)         if (is.NilF (projected))             ConsF (list (list ()), Left (list ()))         else {             xs = projected$carrier             ConsF (list (a), Right (xs))         }     }     apo (coalg, lst) }  tailsApo (list (1,0,2,4,3)) #> [[1]] #> [[1]][[1]] #> [1] 1 #>  #> [[1]][[2]] #> [1] 0 #>  #> [[1]][[3]] #> [1] 2 #>  #> [[1]][[4]] #> [1] 4 #>  #> [[1]][[5]] #> [1] 3 #>  #>  #> [[2]] #> [[2]][[1]] #> [1] 0 #>  #> [[2]][[2]] #> [1] 2 #>  #> [[2]][[3]] #> [1] 4 #>  #> [[2]][[4]] #> [1] 3 #>  #>  #> [[3]] #> [[3]][[1]] #> [1] 2 #>  #> [[3]][[2]] #> [1] 4 #>  #> [[3]][[3]] #> [1] 3 #>  #>  #> [[4]] #> [[4]][[1]] #> [1] 4 #>  #> [[4]][[2]] #> [1] 3 #>  #>  #> [[5]] #> [[5]][[1]] #> [1] 3 #>  #>  #> [[6]] #> list() tailsApoZero <- function (lst) {     coalg = function (a) {         projected = project (a)                  if (projected$attr == 0)             ConsF (list (a), Left (list()))         else if (is.NilF (projected))             ConsF (list (list ()), Left (list ()))         else {             xs = projected$carrier             ConsF (list (a), Right (xs))         }     }     apo (coalg, lst) }  tailsApoZero (list (1,0,2,4,3)) #> [[1]] #> [[1]][[1]] #> [1] 1 #>  #> [[1]][[2]] #> [1] 0 #>  #> [[1]][[3]] #> [1] 2 #>  #> [[1]][[4]] #> [1] 4 #>  #> [[1]][[5]] #> [1] 3 #>  #>  #> [[2]] #> [[2]][[1]] #> [1] 0 #>  #> [[2]][[2]] #> [1] 2 #>  #> [[2]][[3]] #> [1] 4 #>  #> [[2]][[4]] #> [1] 3"},{"path":"/articles/list-morphisms.html","id":"futumorphism","dir":"Articles","previous_headings":"Unfolds","what":"Futumorphism","title":"Morphisms for a list","text":"futumorphism categorical dual histomorphism. Instead access previously-computed answers, futumorphism provides access values yet computed. implementation exchange function given. example usually implemented swaps pairs. example instead swaps sets three shows better access ‘future’ values. R lacks pattern matching Haskell ; Haskell equivalent much succint.","code":"exchange <- function (lst) {         coalg = function (a) {         projected = project (a)                  if (is.NilF (projected))             return (NilF())         else {             x = projected$attr             k = projected$carrier             projected_ = project (k)                if (is.NilF (projected_))                 return (ConsF (x, liftF (NilF())))             else {                 x_ = projected_$attr                 k_ = projected_$carrier                 projected__ = project (k_)                                  if (is.NilF (projected__))                     return (ConsF (x_, liftF (ConsF (x, k_))))                 else {                     x__ = projected__$attr                     k__ = projected__$carrier                                          return (ConsF (x__, Free (ConsF (x_, liftF (ConsF (x, k__))))))                 }             }         }     }     futu (coalg, lst) }  exchange (as.list (1:9)) #> [[1]] #> [1] 3 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 1 #>  #> [[4]] #> [1] 6 #>  #> [[5]] #> [1] 5 #>  #> [[6]] #> [1] 4 #>  #> [[7]] #> [1] 9 #>  #> [[8]] #> [1] 8 #>  #> [[9]] #> [1] 7"},{"path":"/articles/tree-morphisms.html","id":"preface","dir":"Articles","previous_headings":"","what":"Preface","title":"Morphisms for a tree","text":"vignette tutorial walks implementation base functors existing tree object (Node, data.tree), followed implementing custom Tree type behaves similarly. types, tutorial guides building functions make use morphisms included package. However, become clear, writing unfolds (apo, para, futu) data.tree Node problematic. problem arise adding child nodes named existing node tree, behaviour unpredictable. Sample code produces behaviour included tutorial, lead directly custom Tree type , fully-featured functionality data.tree, behave predictably duplicate nodes.","code":""},{"path":[]},{"path":"/articles/tree-morphisms.html","id":"defining-flat-map","dir":"Articles","previous_headings":"The data.tree Node type","what":"Defining flat-map","title":"Morphisms for a tree","text":"Let’s start implementing flat-map data.tree Node object. Confusingly, referencing data.tree object new variable also affects original object. need clone object, efficient, fine example, always returns new object without affecting original.","code":"library (data.tree)  fmap.Node <- function (tr, f) {     working = Clone (tr, attributes=F)      traversal = Traverse (working)     Do (traversal, function(node) node$name <- f (node$name))          return (working) }"},{"path":"/articles/tree-morphisms.html","id":"defining-the-base-functor","dir":"Articles","previous_headings":"The data.tree Node type","what":"Defining the “base” functor","title":"Morphisms for a tree","text":"“base” functor Node object label/attribute type called root carrier type called forest. flat-map function acts carrier type, unless forest empty (’ve hit ‘leaf’) case acts attribute type.","code":"NodeF <- function (r, l) {     res         = list (type = \"NodeF\", root=r, forest=l)     class (res) = \"NodeF\"     return (res) } is.NodeF <- function (trf) {     return (\"NodeF\" %in% class (l)) } fmap.NodeF <- function (nf, f) {     if (length (nf$forest) == 0)         return (NodeF (nf$root, list()))     else         return (NodeF (nf$root, fmap (nf$forest, f))) }"},{"path":"/articles/tree-morphisms.html","id":"translating-between-the-functor-and-its-base-functor","dir":"Articles","previous_headings":"The data.tree Node type","what":"Translating between the functor and its “base” functor","title":"Morphisms for a tree","text":"need two functions unwrap wrap level recursion, respectively. project function take Node “project” one layer onto “base” functor, embed function take Node “base” functor “embed” one layer tree structure. project function Node object follows: contrast, writing embed() function ends problematic behaviour Node$AddChildNode duplicated nodes, assuming duplicates extant, following function works:","code":"project.Node <- function (node)     return (NodeF (node$name, node$children)) embed.NodeF <- function (nf) {     if (length (nf$forest) == 0)         return (Node$new (nf$root))     else {         staging = Node$new (nf$root)         lapply (nf$forest, staging$AddChildNode)         return (staging)     } }"},{"path":"/articles/tree-morphisms.html","id":"conversion-to-a-list-of-lists-and-vice-versa","dir":"Articles","previous_headings":"The data.tree Node type","what":"Conversion to a list of lists and vice versa","title":"Morphisms for a tree","text":"data.tree package includes functions ToListSimple FromListSimple. example uses acme example package vignette contains duplicate nodes, converts list lists, demonstrates use cata ana convert list lists Tree type. Note functions assume one label vignette example. data.tree, actually possible arbitrary number labels, although aren’t displayed default printing function. sample data given data.tree introduction: Now list lists work , can use ana build Node structure, cata tear back : can now combine two get result put :","code":"library (data.tree)  acme <- Node$new(\"Acme Inc.\")   accounting <- acme$AddChild(\"Accounting\")     software <- accounting$AddChild(\"New Software\")     standards <- accounting$AddChild(\"New Accounting Standards\")   research <- acme$AddChild(\"Research\")     newProductLine <- research$AddChild(\"New Product Line\")     newLabs <- research$AddChild(\"New Labs\")   it <- acme$AddChild(\"IT\")     outsource <- it$AddChild(\"Outsource\")     agile <- it$AddChild(\"Go agile\")     goToR <- it$AddChild(\"Switch to R\")      acme #>                           levelName #> 1  Acme Inc.                        #> 2   ¦--Accounting                   #> 3   ¦   ¦--New Software             #> 4   ¦   °--New Accounting Standards #> 5   ¦--Research                     #> 6   ¦   ¦--New Product Line         #> 7   ¦   °--New Labs                 #> 8   °--IT                           #> 9       ¦--Outsource                #> 10      ¦--Go agile                 #> 11      °--Switch to R fromNestedList <- function (lst) {     fromNested = function (nl) {         NodeF (nl$name, nl[-1])     }     ana (fromNested, lst) }  toNestedList <- function (node) {     toNested = function (nf) {         branch = list (name = nf$root)         return (append (branch, nf$forest))     }     cata (toNested, node) } acme |> ToListSimple () |> fromNestedList () |> toNestedList () |> FromListSimple () #>                           levelName #> 1  Acme Inc.                        #> 2   ¦--Accounting                   #> 3   ¦   ¦--New Software             #> 4   ¦   °--New Accounting Standards #> 5   ¦--Research                     #> 6   ¦   ¦--New Product Line         #> 7   ¦   °--New Labs                 #> 8   °--IT                           #> 9       ¦--Outsource                #> 10      ¦--Go agile                 #> 11      °--Switch to R"},{"path":"/articles/tree-morphisms.html","id":"pretty-printing-trees","dir":"Articles","previous_headings":"The data.tree Node type","what":"Pretty-printing trees","title":"Morphisms for a tree","text":"following example based one Stack Overflow, although generalises non-binary trees. main advantage using cata, follows, able reduce recursive calls prettyPrintForest() prettyPrintHelper(), , confusingly, call . Otherwise, function follows still fairly complicated. Given apo gives access level information, histo gives access past results, feasible write function makes use .","code":"drawTree <- function (tree) {     pad = function (body, final, l) {         if (length (l) == 0)             return (list())         else if (length (l) == 1)             return (list (paste (body, l[[1]], sep='')))         else {             firstPortion = l[[1]]             lastPortion  = l[2:length(l)]              res = append (list (paste (body, firstPortion, collapse='', sep=''))                         , lapply (lastPortion, \\(x) paste (final, x, sep='')))             return (res)         }     }      prettyPrintHelper <- function (br) {         if (length (br$forest) == 0)             return (list (br$root))         else             return (append (list (br$root), prettyPrintForest (br)))     }     prettyPrintForest <- function (br) {         forest = br$forest         forlen = length (forest)          if (forlen == 1)             return (pad (\"┗━ \", \"   \", prettyPrintHelper (forest[[1]])))         else {             padding1 = lapply (forest[1:(forlen-1)]                              , \\(x) pad (\"┣━ \", \"┃  \", prettyPrintHelper (x)))             padding2 = pad (\"┗━ \", \"   \", prettyPrintHelper (forest[[forlen]]))              return (append (padding1, padding2))         }     }     cat (paste (as.list (unlist (prettyPrintHelper (tree), recursive=F))               , collapse=\"\\n\", sep='')        , '\\n') } drawTreeCata <- function (tree) {     pad = function (body, final, l) {         if (length (l) == 0)             return (list())         else if (length (l) == 1)             return (list (paste (body, l[[1]], sep='')))         else             return (append (list (paste (body, l[[1]], collapse='', sep=''))                           , lapply (l[2:length(l)], \\(x) paste (final, x, sep=''))))     }     prettyPrint <- function (br) {         if (length (br$forest) == 0)             return (list (br$root))         else if (length (br$forest) == 1)             return (append (pad (\"┗━ \", \"   \", br$forest), br$root, after = 0))         else {             forest = br$forest             forlen = length (forest)                          padding1 = lapply (forest[1:forlen-1], \\(x) pad (\"┣━ \", \"┃  \", x))             padding2 = pad (\"┗━ \", \"   \", forest[[forlen]])             padding = append (padding1, padding2)                          return (append (padding, br$root, after = 0))         }     }     res = cata (prettyPrint, tree)     cat (paste (purrr::flatten (res), collapse='\\n', sep=''), '\\n') }  acme |> ToListSimple () |> fromNestedList () |> drawTreeCata () #> Acme Inc. #> ┣━ Accounting #> ┃  ┣━ New Software #> ┃  ┗━ New Accounting Standards #> ┣━ Research #> ┃  ┣━ New Product Line #> ┃  ┗━ New Labs #> ┗━ IT #>    ┣━ Outsource #>    ┣━ Go agile #>    ┗━ Switch to R"},{"path":"/articles/tree-morphisms.html","id":"tripping-up-data-tree","dir":"Articles","previous_headings":"The data.tree Node type","what":"Tripping up data.tree","title":"Morphisms for a tree","text":"examples work fine, ’s fairly trivial trip data.tree . expected behaviour add another, identical sub-tree, called “rabbit family”, sub-trees end getting mixed, lost.","code":"dups <- Node$new(\"rabbit warren\")   family1 <- dups$AddChild (\"rabbit family\")     rabbit1.1 <- family1$AddChild (\"rabbit matriarch\")     rabbit1.2 <- family1$AddChild (\"rabbit baby\")     rabbit1.3 <- family1$AddChild (\"rabbit engineer\")   family2 <- dups$AddChild (\"rabbit family\")     rabbit2.1 <- family2$AddChild (\"rabbit matriarch\")     rabbit2.2 <- family2$AddChild (\"rabbit scout\")     rabbit2.3 <- family2$AddChild (\"rabbit professor\")   family3 <- dups$AddChild (\"solitary pair of hares\")     hare1 <- family3$AddChild (\"solitary hare #1\")   family4 <- dups$AddChild (\"solitary hare #2\")   family5 <- dups$AddChild (\"solitary hare #2\")  dups #>                    levelName #> 1 rabbit warren              #> 2  ¦--rabbit family          #> 3  ¦   ¦--rabbit matriarch   #> 4  ¦   ¦--rabbit scout       #> 5  ¦   °--rabbit professor   #> 6  ¦--solitary pair of hares #> 7  ¦   °--solitary hare #1   #> 8  °--solitary hare #2"},{"path":[]},{"path":"/articles/tree-morphisms.html","id":"defining-a-custom-tree-type","dir":"Articles","previous_headings":"A custom Tree type","what":"Defining a custom Tree type","title":"Morphisms for a tree","text":"Since ’re using existing type, need define functions generate new S3 type Tree, flat-map implementation.","code":"Tree <- function (r, l) {     res         = list (type = \"Tree\", root=r, forest=l)     class (res) = \"Tree\"     return (res) } is.Tree <- function (x) {     return (\"Tree\" %in% class (x)) }  fmap.Tree <- function (tr, f) {     if (length (tr$forest) == 0)         return (Tree (f (tr$root), list()))     else {         newForest = fmap (tr$forest, \\(x) fmap.Tree (x, f))         return (Tree (f (tr$root), newForest))     } }"},{"path":"/articles/tree-morphisms.html","id":"defining-the-base-functor-1","dir":"Articles","previous_headings":"A custom Tree type","what":"Defining the “base” functor","title":"Morphisms for a tree","text":"Now, define TreeF, “base” functor Tree. near-identical NodeF, come handy later.","code":"TreeF <- function (r, l) {     res         = list (type = \"TreeF\", root=r, forest=l)     class (res) = \"TreeF\"     return (res) }  is.TreeF <- function (trf) {     return (\"TreeF\" %in% class (l)) }  fmap.TreeF <- function (trf, f) {     if (length (trf$forest) == 0)         return (TreeF (trf$root, list()))     else         return (TreeF (trf$root, fmap (trf$forest, f))) }"},{"path":"/articles/tree-morphisms.html","id":"translating-between-the-functor-and-its-base-functor-1","dir":"Articles","previous_headings":"A custom Tree type","what":"Translating between the functor and its “base” functor","title":"Morphisms for a tree","text":"Now, define project() embed() TreeF Tree.","code":"project.Tree <- function (tr) {     return (TreeF (tr$root, tr$forest)) } embed.TreeF <- function (trf) {     return (Tree (trf$root, trf$forest)) }"},{"path":"/articles/tree-morphisms.html","id":"redefining-the-fromnestedlist-function","dir":"Articles","previous_headings":"A custom Tree type","what":"Redefining the fromNestedList() function","title":"Morphisms for a tree","text":"Recall “base” functor new Tree type near-identical “base” functor data.tree Node type. NodeF TreeF S3 objects fundamentally list $carrier $forest attributes. Therefore, sufficient just redefine fromNestedList(), change returning TreeF opposed NodeF. Indeed, possible call drawTreeCata() directly Tree object.","code":"fromNestedList_ <- function (lst) {     fromNested = function (nl) {         TreeF (nl$name, nl[-1])     }     ana (fromNested, lst) }  acme |> ToListSimple () |> fromNestedList_ () |> drawTreeCata () #> Acme Inc. #> ┣━ Accounting #> ┃  ┣━ New Software #> ┃  ┗━ New Accounting Standards #> ┣━ Research #> ┃  ┣━ New Product Line #> ┃  ┗━ New Labs #> ┗━ IT #>    ┣━ Outsource #>    ┣━ Go agile #>    ┗━ Switch to R"},{"path":"/articles/tree-morphisms.html","id":"implementing-a-monad-instance","dir":"Articles","previous_headings":"A custom Tree type","what":"Implementing a monad instance","title":"Morphisms for a tree","text":"bonus, can also define monad instance new Tree type. Let’s check monad laws, can summarised follows: Left identity: Right identity: Associativity: First, define equivalent Haskell’s return(), ’ve called escape: Now, implement laws code: Evaluate equivalence drawing trees terminal: looks like type satisfies monad laws. However, implementing unit test, list type, non-trivial, R way know two Tree objects equal. Writing function compare structure / node values enable formally testing equality LHS/RHS trees. Anyway, implementing bind enables neat operations like following:","code":"bind.Tree <- function (tr, f) {     x   = tr$root     txs = tr$forest          k = f(x)     y   = k$root     tys = k$forest     p = lapply (txs, \\(a) a %>>=% f)     return (Tree (y, c(tys, p))) } return >=> h ≡ h f >=> return ≡ f (f >=> g) >=> h ≡ f >=> (g >=> h) escape.Tree <- function (x)     return (Tree (x, list()))  f <- function (x)     return (Tree (x+2, list (escape.Tree (x+3), escape.Tree (x+4)))) g <- function (x)     return (Tree (x+4, list ())) leftIdentityLHS <- escape.Tree (3) %>>=% f leftIdentityRHS <- f (3)  rightIdentityLHS <- f (3) %>>=% escape.Tree rightIdentityRHS <- f (3)  associativityTestTree <- Tree (3, list (                            Tree (4, list())                          , Tree (5, list(Tree (6, list()), Tree (7, list())))                          )) associativityLHS <- (associativityTestTree %>>=% f) %>>=% g associativityRHS <- associativityTestTree %>>=% (\\(x) f(x) %>>=% g) leftIdentityLHS |> drawTreeCata () #> 5 #> ┣━ 6 #> ┗━ 7 leftIdentityRHS |> drawTreeCata () #> 5 #> ┣━ 6 #> ┗━ 7 rightIdentityLHS |> drawTreeCata () #> 5 #> ┣━ 6 #> ┗━ 7 rightIdentityRHS |> drawTreeCata () #> 5 #> ┣━ 6 #> ┗━ 7 associativityLHS |> drawTreeCata () #> 9 #> ┣━ 10 #> ┣━ 11 #> ┣━ 10 #> ┃  ┣━ 11 #> ┃  ┗━ 12 #> ┗━ 11 #>    ┣━ 12 #>    ┣━ 13 #>    ┣━ 12 #>    ┃  ┣━ 13 #>    ┃  ┗━ 14 #>    ┗━ 13 #>       ┣━ 14 #>       ┗━ 15 associativityRHS |> drawTreeCata () #> 9 #> ┣━ 10 #> ┣━ 11 #> ┣━ 10 #> ┃  ┣━ 11 #> ┃  ┗━ 12 #> ┗━ 11 #>    ┣━ 12 #>    ┣━ 13 #>    ┣━ 12 #>    ┃  ┣━ 13 #>    ┃  ┗━ 14 #>    ┗━ 13 #>       ┣━ 14 #>       ┗━ 15 acme_ <- acme |> ToListSimple () |> fromNestedList_ ()  treeToUpper <- purrr::compose (escape.Tree, toupper)  acme_ %>>=% treeToUpper |> drawTreeCata () #> ACME INC. #> ┣━ ACCOUNTING #> ┃  ┣━ NEW SOFTWARE #> ┃  ┗━ NEW ACCOUNTING STANDARDS #> ┣━ RESEARCH #> ┃  ┣━ NEW PRODUCT LINE #> ┃  ┗━ NEW LABS #> ┗━ IT #>    ┣━ OUTSOURCE #>    ┣━ GO AGILE #>    ┗━ SWITCH TO R"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"D Guthrie. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Guthrie D (2023). recursr: Generalised Folds Unfolds R. R package version 0.1.","code":"@Manual{,   title = {recursr: Generalised Folds and Unfolds for R},   author = {D Guthrie},   year = {2023},   note = {R package version 0.1}, }"},{"path":[]},{"path":"/index.html","id":"preface","dir":"","previous_headings":"","what":"Preface","title":"Generalised Folds and Unfolds for R","text":"experiment porting Haskell recursion-schemes package R. generalised fold unfolding functions, can applied large number data structures. package includes just enough Haskell language infrastructure make possible use following recursion schemes: catamorphism categorical dual anamorphism paramorphism categorical dual apomorphism histomorphism categorical dual futumorphism Refolds like hylomorphism implemented, possible implement using building blocks.","code":""},{"path":"/index.html","id":"tutorial-articles-vignettes-and-package-license","dir":"","previous_headings":"","what":"Tutorial articles (vignettes) and package license","title":"Generalised Folds and Unfolds for R","text":"first package vignette tutorial making use various morphisms familiar list type. primarily demonstration function rather explanation implement “base” functor given type. second package vignette explores implementation flat-map data.tree package’s Node type, implementation “base” functor type. package’s unpredictable behaviour, vignette explores implementation basic Tree type. Finally, explores implementation monad instance basic Tree type, testing monad laws. third package vignette explores using fixed-points instead project()/embed(), demonstrates using Peano numbers. building/testing library, used fixed-points instead project()/embed() functions, later replaced code functions, also adapted “base” functor list demonstrate package, library extent adapted Haskell recursion-schemes package. isn’t clear implications terms software licensing adapting code/ideas (libraries implement recursion-schemes SCALA’s matryoshka don’t share license recursion-schemes), ’ve applied license (BSD 2-Clause) note attribution. code licensed BSD 2-Clause.","code":""},{"path":"/index.html","id":"recursion-schemes","dir":"","previous_headings":"","what":"Recursion schemes","title":"Generalised Folds and Unfolds for R","text":"package explain different recursion schemes actually , think others done better . initial explorations catamorphisms anamorphisms largely inspired following, excellent, series blog-posts: https://blog.ploeh.dk/2017/10/04/-design-patterns--category-theory/ (Seemann’s book Code Fits Head also happens good.) resources fairly accessible include following: https://jtobin.io/practical-recursion-schemes (series) https://blog.sumtypeofway.com/posts/introduction--recursion-schemes.html (series) https://fho.f12n.de/posts/2014-05-07-dont-fear--cat.html https://arxiv.org/pdf/2202.13633.pdf","code":""},{"path":"/index.html","id":"additional-features-implemented","dir":"","previous_headings":"","what":"Additional features implemented","title":"Generalised Folds and Unfolds for R","text":"Futu histo depend free monad cofree comonad, para apo depend either monad tuples. , following language features also implemented: S3 methods functors (flat-map .k.. fmap()) S3 methods monads (bind .k.. >>=, discard .k.. >>, join()) S3 methods comonads (extract(), extend(), duplicate()) Infix pipes work like Haskell infix operators, surrounded percentage signs similar magrittr pipes Thus enabling following: free monad cofree comonad flat-map bind implementation list “Base” functor list, represents list functor given point recursion Either monad, well Tuple, flat-map implementation bind implementation Either. tuples monads. Note Haskell another typeclass, bears mentioning, Applicative. fact, monads applicative functors. However, Applicative instances pretty unintuitive, invariably one possible Applicative instance, ’ve implemented Applicative types package.","code":""},{"path":"/index.html","id":"the-r-type-system-or-lack-thereof","dir":"","previous_headings":"","what":"The R type system (or lack thereof)","title":"Generalised Folds and Unfolds for R","text":"R strongly-typed—freely coerce values—S3 class system least enable writing functions specific given functor/monad, e.g. bind implementation Either applies Either values.","code":""},{"path":"/reference/Cofree.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a cofree comonad — Cofree","title":"Construct a cofree comonad — Cofree","text":"Construct cofree comonad","code":""},{"path":"/reference/Cofree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a cofree comonad — Cofree","text":"","code":"Cofree(attr, carrier)"},{"path":"/reference/Cofree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a cofree comonad — Cofree","text":"attr comonad attribute carrier comonad carrier","code":""},{"path":"/reference/ConsF.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a Cons value of the list base functor — ConsF","title":"Construct a Cons value of the list base functor — ConsF","text":"Construct Cons value list base functor","code":""},{"path":"/reference/ConsF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Cons value of the list base functor — ConsF","text":"","code":"ConsF(x, xs)"},{"path":"/reference/ConsF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Cons value of the list base functor — ConsF","text":"x First list element xs Subsequent list elements, constructed Cons","code":""},{"path":"/reference/Free.html","id":null,"dir":"Reference","previous_headings":"","what":"Free constructor of a free monad — Free","title":"Free constructor of a free monad — Free","text":"Free constructor free monad","code":""},{"path":"/reference/Free.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Free constructor of a free monad — Free","text":"","code":"Free(fnct)"},{"path":"/reference/Free.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Free constructor of a free monad — Free","text":"fnct given functor","code":""},{"path":"/reference/Left.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a Left value of the Either monad — Left","title":"Construct a Left value of the Either monad — Left","text":"Construct Left value Either monad","code":""},{"path":"/reference/Left.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Left value of the Either monad — Left","text":"","code":"Left(x)"},{"path":"/reference/Left.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Left value of the Either monad — Left","text":"x value wrapped Left","code":""},{"path":"/reference/NilF.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a Nil value of the list base functor — NilF","title":"Construct a Nil value of the list base functor — NilF","text":"Construct Nil value list base functor","code":""},{"path":"/reference/NilF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Nil value of the list base functor — NilF","text":"","code":"NilF()"},{"path":"/reference/Pure.html","id":null,"dir":"Reference","previous_headings":"","what":"Pure constructor of a free monad — Pure","title":"Pure constructor of a free monad — Pure","text":"Pure constructor free monad","code":""},{"path":"/reference/Pure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pure constructor of a free monad — Pure","text":"","code":"Pure(fnct)"},{"path":"/reference/Pure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pure constructor of a free monad — Pure","text":"fnct given functor","code":""},{"path":"/reference/Right.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a Right value of the Either monad — Right","title":"Construct a Right value of the Either monad — Right","text":"Construct Right value Either monad","code":""},{"path":"/reference/Right.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a Right value of the Either monad — Right","text":"","code":"Right(x)"},{"path":"/reference/Right.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a Right value of the Either monad — Right","text":"x value wrapped Right","code":""},{"path":"/reference/Tuple.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a tuple — Tuple","title":"Construct a tuple — Tuple","text":"Construct tuple","code":""},{"path":"/reference/Tuple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a tuple — Tuple","text":"","code":"Tuple(x, y)"},{"path":"/reference/Tuple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a tuple — Tuple","text":"x First element y Second element","code":""},{"path":"/reference/ana.html","id":null,"dir":"Reference","previous_headings":"","what":"The anamorphism, categorical dual of the catamorphism — ana","title":"The anamorphism, categorical dual of the catamorphism — ana","text":"anamorphism, categorical dual catamorphism","code":""},{"path":"/reference/ana.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The anamorphism, categorical dual of the catamorphism — ana","text":"","code":"ana(coalg, expr)"},{"path":"/reference/ana.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The anamorphism, categorical dual of the catamorphism — ana","text":"coalg coalgebra expr terminal expression","code":""},{"path":"/reference/apo.html","id":null,"dir":"Reference","previous_headings":"","what":"The apomorphism, categorical dual of the paramorphism — apo","title":"The apomorphism, categorical dual of the paramorphism — apo","text":"apomorphism, categorical dual paramorphism","code":""},{"path":"/reference/apo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The apomorphism, categorical dual of the paramorphism — apo","text":"","code":"apo(coalg, expr)"},{"path":"/reference/apo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The apomorphism, categorical dual of the paramorphism — apo","text":"coalg coalgebra expr terminal expression","code":""},{"path":"/reference/as.character.tuple.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a text representation of a tuple — as.character.tuple","title":"Get a text representation of a tuple — as.character.tuple","text":"Get text representation tuple","code":""},{"path":"/reference/as.character.tuple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a text representation of a tuple — as.character.tuple","text":"","code":"# S3 method for tuple as.character(t)"},{"path":"/reference/as.character.tuple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a text representation of a tuple — as.character.tuple","text":"t tuple","code":""},{"path":"/reference/bind.Either.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind a list — bind.Either","title":"Bind a list — bind.Either","text":"Bind list","code":""},{"path":"/reference/bind.Either.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind a list — bind.Either","text":"","code":"# S3 method for Either bind(ex, f)"},{"path":"/reference/bind.Either.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind a list — bind.Either","text":"ex Either monad f function bind Either monad","code":""},{"path":"/reference/bind.free.monad.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind operation for a free monaad — bind.free.monad","title":"Bind operation for a free monaad — bind.free.monad","text":"Bind operation free monaad","code":""},{"path":"/reference/bind.free.monad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind operation for a free monaad — bind.free.monad","text":"","code":"# S3 method for free.monad bind(fr, f)"},{"path":"/reference/bind.free.monad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind operation for a free monaad — bind.free.monad","text":"fr free monad f function bind","code":""},{"path":"/reference/bind.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind a monad — bind","title":"Bind a monad — bind","text":"Bind monad","code":""},{"path":"/reference/bind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind a monad — bind","text":"","code":"bind(m, ...)"},{"path":"/reference/bind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind a monad — bind","text":"m monad f function bind monad","code":""},{"path":"/reference/bind.list.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind a list — bind.list","title":"Bind a list — bind.list","text":"Bind list","code":""},{"path":"/reference/bind.list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind a list — bind.list","text":"","code":"# S3 method for list bind(lst, f)"},{"path":"/reference/bind.list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind a list — bind.list","text":"lst list f function bind list","code":""},{"path":"/reference/cata.html","id":null,"dir":"Reference","previous_headings":"","what":"The catamorphism — cata","title":"The catamorphism — cata","text":"catamorphism","code":""},{"path":"/reference/cata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The catamorphism — cata","text":"","code":"cata(alg, expr)"},{"path":"/reference/cata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The catamorphism — cata","text":"alg algebra expr initial expression","code":""},{"path":"/reference/duplicate.html","id":null,"dir":"Reference","previous_headings":"","what":"Create two comonads from a single one — duplicate","title":"Create two comonads from a single one — duplicate","text":"Create two comonads single one","code":""},{"path":"/reference/duplicate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create two comonads from a single one — duplicate","text":"","code":"duplicate(cm)"},{"path":"/reference/duplicate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create two comonads from a single one — duplicate","text":"cm comonad","code":""},{"path":"/reference/either.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a function depending on whether an Either value is Left or Right — either","title":"Run a function depending on whether an Either value is Left or Right — either","text":"Run function depending whether Either value Left Right","code":""},{"path":"/reference/either.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a function depending on whether an Either value is Left or Right — either","text":"","code":"either(fl, fr, ex)"},{"path":"/reference/either.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a function depending on whether an Either value is Left or Right — either","text":"fl function run value held Left value fr function run value held Right value ex value check","code":""},{"path":"/reference/embed.ListF.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrap a single layer of recursion — embed.ListF","title":"Wrap a single layer of recursion — embed.ListF","text":"Wrap single layer recursion","code":""},{"path":"/reference/embed.ListF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrap a single layer of recursion — embed.ListF","text":"","code":"# S3 method for ListF embed(lstf)"},{"path":"/reference/embed.ListF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrap a single layer of recursion — embed.ListF","text":"lstf list base functor","code":""},{"path":"/reference/embed.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrap a single layer of recursion — embed","title":"Wrap a single layer of recursion — embed","text":"Wrap single layer recursion","code":""},{"path":"/reference/embed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrap a single layer of recursion — embed","text":"","code":"embed(x, ...)"},{"path":"/reference/embed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrap a single layer of recursion — embed","text":"bf base functor","code":""},{"path":"/reference/equals-.Either.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare two Either monads — ==.Either","title":"Compare two Either monads — ==.Either","text":"Compare two Either monads","code":""},{"path":"/reference/equals-.Either.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare two Either monads — ==.Either","text":"","code":"# S3 method for Either ==(x, y)"},{"path":"/reference/equals-.Either.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare two Either monads — ==.Either","text":"x Either monad y Another Either monad","code":""},{"path":"/reference/equals-.tuple.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare two tuple objects — ==.tuple","title":"Compare two tuple objects — ==.tuple","text":"Compare two tuple objects","code":""},{"path":"/reference/equals-.tuple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare two tuple objects — ==.tuple","text":"","code":"# S3 method for tuple ==(x, y)"},{"path":"/reference/equals-.tuple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare two tuple objects — ==.tuple","text":"x tuple y Another tuple","code":""},{"path":"/reference/extend.cofree.comonad.html","id":null,"dir":"Reference","previous_headings":"","what":"Take a function and apply it to the comonad's attribute — extend.cofree.comonad","title":"Take a function and apply it to the comonad's attribute — extend.cofree.comonad","text":"Take function apply comonad's attribute","code":""},{"path":"/reference/extend.cofree.comonad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Take a function and apply it to the comonad's attribute — extend.cofree.comonad","text":"","code":"# S3 method for cofree.comonad extend(cfr, f)"},{"path":"/reference/extend.cofree.comonad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Take a function and apply it to the comonad's attribute — extend.cofree.comonad","text":"cfr cofree comonad f function apply cofree comonad's attribute","code":""},{"path":"/reference/extend.html","id":null,"dir":"Reference","previous_headings":"","what":"Extend takes a function and applies it to the comonad's attribute — extend","title":"Extend takes a function and applies it to the comonad's attribute — extend","text":"Extend takes function applies comonad's attribute","code":""},{"path":"/reference/extend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extend takes a function and applies it to the comonad's attribute — extend","text":"","code":"extend(cm, ...)"},{"path":"/reference/extend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extend takes a function and applies it to the comonad's attribute — extend","text":"cm comonad f function","code":""},{"path":"/reference/extract.cofree.comonad.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a value from a cofree comonad — extract.cofree.comonad","title":"Extract a value from a cofree comonad — extract.cofree.comonad","text":"Extract value cofree comonad","code":""},{"path":"/reference/extract.cofree.comonad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a value from a cofree comonad — extract.cofree.comonad","text":"","code":"# S3 method for cofree.comonad extract(cfr)"},{"path":"/reference/extract.cofree.comonad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a value from a cofree comonad — extract.cofree.comonad","text":"cfr cofree comonad","code":""},{"path":"/reference/extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a value from a comonad — extract","title":"Extract a value from a comonad — extract","text":"Extract value comonad","code":""},{"path":"/reference/extract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a value from a comonad — extract","text":"","code":"extract(cm, ...)"},{"path":"/reference/extract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a value from a comonad — extract","text":"cm comonad","code":""},{"path":"/reference/first.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the first element of a object — first","title":"Get the first element of a object — first","text":"Get first element object","code":""},{"path":"/reference/first.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the first element of a object — first","text":"","code":"first(x, ...)"},{"path":"/reference/first.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the first element of a object — first","text":"x object","code":""},{"path":"/reference/first.tuple.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the first element of a tuple — first.tuple","title":"Get the first element of a tuple — first.tuple","text":"Get first element tuple","code":""},{"path":"/reference/first.tuple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the first element of a tuple — first.tuple","text":"","code":"# S3 method for tuple first(t)"},{"path":"/reference/first.tuple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the first element of a tuple — first.tuple","text":"t tuple","code":""},{"path":"/reference/fmap.Either.html","id":null,"dir":"Reference","previous_headings":"","what":"Flat-map over an Either monad — fmap.Either","title":"Flat-map over an Either monad — fmap.Either","text":"Flat-map Either monad","code":""},{"path":"/reference/fmap.Either.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flat-map over an Either monad — fmap.Either","text":"","code":"# S3 method for Either fmap(ex, f)"},{"path":"/reference/fmap.Either.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flat-map over an Either monad — fmap.Either","text":"f function flat-map x Either monad","code":""},{"path":"/reference/fmap.ListF.html","id":null,"dir":"Reference","previous_headings":"","what":"Flat-map over a list base functor — fmap.ListF","title":"Flat-map over a list base functor — fmap.ListF","text":"Flat-map list base functor","code":""},{"path":"/reference/fmap.ListF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flat-map over a list base functor — fmap.ListF","text":"","code":"# S3 method for ListF fmap(lstf, f)"},{"path":"/reference/fmap.ListF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flat-map over a list base functor — fmap.ListF","text":"f function flat-map x list base functor","code":""},{"path":"/reference/fmap.free.monad.html","id":null,"dir":"Reference","previous_headings":"","what":"Flat-map over a free monaad — fmap.free.monad","title":"Flat-map over a free monaad — fmap.free.monad","text":"Flat-map free monaad","code":""},{"path":"/reference/fmap.free.monad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flat-map over a free monaad — fmap.free.monad","text":"","code":"# S3 method for free.monad fmap(fr, f)"},{"path":"/reference/fmap.free.monad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flat-map over a free monaad — fmap.free.monad","text":"fr free monad f function flat-map","code":""},{"path":"/reference/fmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Flat-map over a functor — fmap","title":"Flat-map over a functor — fmap","text":"flat-map implemented differently functor, functor satisfying functor laws. Nonetheless set unlike Haskell, use fmap (x, f) rather fmap f x. reason enable use fmap() native pipes without placeholder, e.g. x |> fmap (\\() +2). contrast, infix operator %<$>% works Haskell natural.","code":""},{"path":"/reference/fmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flat-map over a functor — fmap","text":"","code":"fmap(fnct, ...)"},{"path":"/reference/fmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flat-map over a functor — fmap","text":"x functor f function flat-map","code":""},{"path":"/reference/fmap.list.html","id":null,"dir":"Reference","previous_headings":"","what":"Flat-map over a list — fmap.list","title":"Flat-map over a list — fmap.list","text":"Flat-map list","code":""},{"path":"/reference/fmap.list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flat-map over a list — fmap.list","text":"","code":"# S3 method for list fmap(X, FUN, ...)"},{"path":"/reference/fmap.list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flat-map over a list — fmap.list","text":"x list f function flat-map","code":""},{"path":"/reference/fmap.tuple.html","id":null,"dir":"Reference","previous_headings":"","what":"Flat-map over a tuple — fmap.tuple","title":"Flat-map over a tuple — fmap.tuple","text":"Flat-map tuple","code":""},{"path":"/reference/fmap.tuple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flat-map over a tuple — fmap.tuple","text":"","code":"# S3 method for tuple fmap(t, f)"},{"path":"/reference/fmap.tuple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flat-map over a tuple — fmap.tuple","text":"t tuple f function flat-map","code":""},{"path":"/reference/futu.html","id":null,"dir":"Reference","previous_headings":"","what":"The futumorphism, categorical dual of the histomorphism — futu","title":"The futumorphism, categorical dual of the histomorphism — futu","text":"futumorphism, categorical dual histomorphism","code":""},{"path":"/reference/futu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The futumorphism, categorical dual of the histomorphism — futu","text":"","code":"futu(coalg, a)"},{"path":"/reference/futu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The futumorphism, categorical dual of the histomorphism — futu","text":"coalg coalgebra expr terminal expression","code":""},{"path":"/reference/grapes-colon-less-than-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Infix constructor of a cofree comonad — %:<%","title":"Infix constructor of a cofree comonad — %:<%","text":"Infix constructor cofree comonad","code":""},{"path":"/reference/grapes-colon-less-than-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infix constructor of a cofree comonad — %:<%","text":"","code":"attr %:<% carrier"},{"path":"/reference/grapes-colon-less-than-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infix constructor of a cofree comonad — %:<%","text":"attr comonad attribute carrier comonad carrier","code":""},{"path":"/reference/grapes-greater-than-greater-than-equals-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Infix bind — %>>=%","title":"Infix bind — %>>=%","text":"Infix bind","code":""},{"path":"/reference/grapes-greater-than-greater-than-equals-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infix bind — %>>=%","text":"","code":"m %>>=% ..."},{"path":"/reference/grapes-greater-than-greater-than-equals-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infix bind — %>>=%","text":"m monad f function bind monad","code":""},{"path":"/reference/grapes-greater-than-greater-than-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Infix bind-discard — %>>%","title":"Infix bind-discard — %>>%","text":"Infix bind-discard","code":""},{"path":"/reference/grapes-greater-than-greater-than-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infix bind-discard — %>>%","text":"","code":"m %>>% f"},{"path":"/reference/grapes-greater-than-greater-than-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infix bind-discard — %>>%","text":"m monad f function bind monad","code":""},{"path":"/reference/grapes-less-than-cash-greater-than-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Infix flat-map — %<$>%","title":"Infix flat-map — %<$>%","text":"Infix flat-map","code":""},{"path":"/reference/grapes-less-than-cash-greater-than-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infix flat-map — %<$>%","text":"","code":"f %<$>% fnct"},{"path":"/reference/grapes-less-than-cash-greater-than-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infix flat-map — %<$>%","text":"f function flat-map fnct functor","code":""},{"path":"/reference/histo.html","id":null,"dir":"Reference","previous_headings":"","what":"The histomorphism — histo","title":"The histomorphism — histo","text":"histomorphism","code":""},{"path":"/reference/histo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The histomorphism — histo","text":"","code":"histo(alg, expr)"},{"path":"/reference/histo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The histomorphism — histo","text":"alg algebra expr initial expression","code":""},{"path":"/reference/is.Cofree.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an expression is a cofree comonad — is.Cofree","title":"Check if an expression is a cofree comonad — is.Cofree","text":"Check expression cofree comonad","code":""},{"path":"/reference/is.Cofree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an expression is a cofree comonad — is.Cofree","text":"","code":"is.Cofree(x)"},{"path":"/reference/is.Cofree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an expression is a cofree comonad — is.Cofree","text":"x value check","code":""},{"path":"/reference/is.ConsF.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a value is a concatenated list base functor — is.ConsF","title":"Check if a value is a concatenated list base functor — is.ConsF","text":"Check value concatenated list base functor","code":""},{"path":"/reference/is.ConsF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a value is a concatenated list base functor — is.ConsF","text":"","code":"is.ConsF(x)"},{"path":"/reference/is.ConsF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a value is a concatenated list base functor — is.ConsF","text":"x value check","code":""},{"path":"/reference/is.Free.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if the Free constructor governs an expression — is.Free","title":"Check if the Free constructor governs an expression — is.Free","text":"Check Free constructor governs expression","code":""},{"path":"/reference/is.Free.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if the Free constructor governs an expression — is.Free","text":"","code":"is.Free(fr)"},{"path":"/reference/is.Free.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if the Free constructor governs an expression — is.Free","text":"fr free monad","code":""},{"path":"/reference/is.Left.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a value is a Right Either monad — is.Left","title":"Check if a value is a Right Either monad — is.Left","text":"Check value Right Either monad","code":""},{"path":"/reference/is.Left.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a value is a Right Either monad — is.Left","text":"","code":"is.Left(x)"},{"path":"/reference/is.Left.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a value is a Right Either monad — is.Left","text":"x value check","code":""},{"path":"/reference/is.NilF.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a value is a nil base functor — is.NilF","title":"Check if a value is a nil base functor — is.NilF","text":"Check value nil base functor","code":""},{"path":"/reference/is.NilF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a value is a nil base functor — is.NilF","text":"","code":"is.NilF(x)"},{"path":"/reference/is.NilF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a value is a nil base functor — is.NilF","text":"x value check","code":""},{"path":"/reference/is.Pure.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if the Pure constructor governs an expression — is.Pure","title":"Check if the Pure constructor governs an expression — is.Pure","text":"Check Pure constructor governs expression","code":""},{"path":"/reference/is.Pure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if the Pure constructor governs an expression — is.Pure","text":"","code":"is.Pure(fr)"},{"path":"/reference/is.Pure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if the Pure constructor governs an expression — is.Pure","text":"fr free monad","code":""},{"path":"/reference/is.Right.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a value is a Right Either monad — is.Right","title":"Check if a value is a Right Either monad — is.Right","text":"Check value Right Either monad","code":""},{"path":"/reference/is.Right.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a value is a Right Either monad — is.Right","text":"","code":"is.Right(x)"},{"path":"/reference/is.Right.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a value is a Right Either monad — is.Right","text":"x value check","code":""},{"path":"/reference/join.html","id":null,"dir":"Reference","previous_headings":"","what":"Join a monad — join","title":"Join a monad — join","text":"Join monad","code":""},{"path":"/reference/join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Join a monad — join","text":"","code":"join(m)"},{"path":"/reference/join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Join a monad — join","text":"m monad","code":""},{"path":"/reference/liftF.html","id":null,"dir":"Reference","previous_headings":"","what":"Lift a functor into the free monad — liftF","title":"Lift a functor into the free monad — liftF","text":"Lift functor free monad","code":""},{"path":"/reference/liftF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lift a functor into the free monad — liftF","text":"","code":"liftF(fnct)"},{"path":"/reference/liftF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lift a functor into the free monad — liftF","text":"fnct functor","code":""},{"path":"/reference/mdiscard.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind a monad, albeit discard the initial result — mdiscard","title":"Bind a monad, albeit discard the initial result — mdiscard","text":"Bind monad, albeit discard initial result","code":""},{"path":"/reference/mdiscard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind a monad, albeit discard the initial result — mdiscard","text":"","code":"mdiscard(m, f)"},{"path":"/reference/mdiscard.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind a monad, albeit discard the initial result — mdiscard","text":"m monad f function bind monad","code":""},{"path":"/reference/para.html","id":null,"dir":"Reference","previous_headings":"","what":"The paramorphism — para","title":"The paramorphism — para","text":"paramorphism","code":""},{"path":"/reference/para.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The paramorphism — para","text":"","code":"para(alg, expr)"},{"path":"/reference/para.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The paramorphism — para","text":"alg algebra expr initial expression","code":""},{"path":"/reference/print.tuple.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a tuple — print.tuple","title":"Print a tuple — print.tuple","text":"Print tuple","code":""},{"path":"/reference/print.tuple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a tuple — print.tuple","text":"","code":"# S3 method for tuple print(t)"},{"path":"/reference/print.tuple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a tuple — print.tuple","text":"t tuple","code":""},{"path":"/reference/project.html","id":null,"dir":"Reference","previous_headings":"","what":"Unwrap a single layer of recursion — project","title":"Unwrap a single layer of recursion — project","text":"Unwrap single layer recursion","code":""},{"path":"/reference/project.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unwrap a single layer of recursion — project","text":"","code":"project(x, ...)"},{"path":"/reference/project.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unwrap a single layer of recursion — project","text":"f functor","code":""},{"path":"/reference/project.list.html","id":null,"dir":"Reference","previous_headings":"","what":"Unwrap a single layer of recursion — project.list","title":"Unwrap a single layer of recursion — project.list","text":"Unwrap single layer recursion","code":""},{"path":"/reference/project.list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unwrap a single layer of recursion — project.list","text":"","code":"# S3 method for list project(lst)"},{"path":"/reference/project.list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unwrap a single layer of recursion — project.list","text":"lst list","code":""},{"path":"/reference/second.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the second element of a object — second","title":"Get the second element of a object — second","text":"Get second element object","code":""},{"path":"/reference/second.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the second element of a object — second","text":"","code":"second(x, ...)"},{"path":"/reference/second.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the second element of a object — second","text":"x object","code":""},{"path":"/reference/second.tuple.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the second element of a tuple — second.tuple","title":"Get the second element of a tuple — second.tuple","text":"Get second element tuple","code":""},{"path":"/reference/second.tuple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the second element of a tuple — second.tuple","text":"","code":"# S3 method for tuple second(t)"},{"path":"/reference/second.tuple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the second element of a tuple — second.tuple","text":"t tuple","code":""}]
